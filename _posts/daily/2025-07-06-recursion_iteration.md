---
layout: post
title: 프로그래밍 언어의 이해 - 재귀와 반복, 기본 Collection
subtitle: Programming Language: Recursion, Iteration, and Basic Collection
tags: [programming language, recursion, iteration, collection]
comments: true
author: widehyo
---

프로그래밍 언어를 구성하는 최소한의 요소 중 하나는 조건문과 반복문이다. 이 중 반복은 언어에 따라 두 가지 메커니즘 중 하나로 구현된다: 이터레이션(iteration) 또는 재귀(recursion).

대부분의 일반적인 언어는 이터레이션을 기본 제공하며, 재귀만을 이용해 반복을 구현하는 언어는 비교적 드물다. 이처럼 재귀 기반의 반복은 함수형 언어에서 주로 등장하며, 아예 `for` 문법이 존재하지 않는 언어도 있다. 본 글에서는 반복이라는 개념을 repeatation이라 하고, 반복을 구현하는 방법으로서의 반복은 iteration으로 구분한다. 두 용어가 혼동될 수 있는 구간에서는 영문 병기를 병행한다.

---

## 반복과 재귀의 저수준 구현

반복과 재귀는 결국 상태 변화(state transition)를 통해 반복을 구현하는 방식이다. 이를 이해하기 위해 저수준 언어인 어셈블리에서 반복을 어떻게 구현하는지 살펴보자.

### 어셈블리에서 반복 구현 방식

어셈블리 수준에서는 반복(repeatation)을 다음 두 가지 방식으로 구현한다:

1. **`jmp`와 `label`을 사용하는 방식**  
   특정 코드 블록에 label을 붙이고, `cmp` 명령으로 두 값을 비교한 후 `ZF(zero flag)`를 설정하여 조건에 따라 `jmp` 계열 명령으로 분기한다. 이 방식은 비교 결과에 따라 분기하며, 조건 상태를 state로 갖는 상태 기계(state machine)로 볼 수 있다.

2. **`loop {label}` 명령어를 사용하는 방식**  
   반복 횟수를 `ecx` 레지스터에 지정하고, `loop` 명령어로 label 블록을 반복 실행한다. 반복 시마다 `ecx`는 1씩 감소하고, 0이 되면 반복이 종료된다. 이 역시 `ecx`의 값을 상태로 갖는 state machine이다.

### 반복 구조와 재귀 구조의 유사성

- `jmp`와 조건 분기를 이용한 방식은 재귀 호출과 유사하게 흐름 제어를 한다.
- `ecx`를 이용한 반복은 `for (int i = 0; i < n; i++)`와 매우 유사한 구조다.

이처럼 반복이든 재귀든 결국은 상태를 기반으로 한 전이 과정을 수행하며, 모두 상태 기계(state machine)로 표현될 수 있다.

---

## 반복은 언제 필요한가?

단순한 예제(구구단, 별찍기 등)를 제외하면, 반복이 사용되는 대부분의 실제 상황은 collection 순회에 기반한다.

- 배열, 리스트 같은 collection의 각 요소를 순회하거나  
- DB에서 가져온 row 집합을 처리하거나  
- 파일 시스템 하위 파일들을 처리하는 경우 등

이러한 경우 반복에서 핵심은 인덱스(counter) 자체가 아니라, 그 인덱스를 이용해 collection에서 요소를 가져오는 과정이다.

---

## 반복의 기반: 두 가지 Collection 구조

프로그래밍 언어에서 반복의 기반이 되는 기본 collection 구조는 두 가지로 나뉜다:

1. **Array 기반 Collection**
2. **Linked List 기반 Collection**

### 1. Array 기반 Collection

- 각 요소가 인접한 메모리에 연속적으로 저장된다.
- 인덱스를 이용해 O(1) 시간에 임의 접근이 가능하다.
- 메모리 접근 효율이 높으며, Java, Python, JavaScript 등 대부분의 언어에서 주력 collection이다.

> 예: `ArrayList`, `vector`, `list`, `tuple`, `array`

### 2. Linked List 기반 Collection

- 각 요소가 포인터를 통해 다음 요소를 가리킨다.
- 접근은 O(n)이 걸리지만, 지연 평가(lazy evaluation)나 무한 시퀀스를 표현할 때 유리하다.
- 함수형 언어(Haskell, Clojure, F# 등)에서 주로 사용된다.

특징적으로, 하나의 노드만으로 전체 리스트를 대표할 수 있다. 이는 `head` 노드만 알고 있다면 순차적으로 모든 요소에 접근할 수 있기 때문이다. 함수형 언어에서 `x:xs`, `(cons 69 (cons 613 nil))`와 같은 패턴이 자연스럽게 쓰이는 이유다.

---

## 이터레이션과 지연 평가

이터레이션은 현재 상태값을 기반으로 다음 값을 생성한다. 이를 통해 다음 요소를 즉시 계산하지 않고 필요할 때 생성하는 지연 평가(lazy evaluation)가 가능해진다.

- Python에서는 `__next__()` 메서드를 통해
- C++에서는 `++` 연산자 오버로딩으로
- Java, JavaScript, Python 등에서는 `yield`, `generator` 키워드를 통해

이터레이터(iterator)를 쉽게 만들 수 있도록 언어 차원의 지원이 존재한다.

---

## 재귀와 콜 스택

재귀(recursion)는 함수가 자기 자신을 호출하는 구조로, 함수 호출마다 새로운 스택 프레임이 생성된다. 이 구조는 다음과 같은 특성을 가진다:

- 메모리 사용이 많고, 호출 깊이에 따라 성능 저하 가능
- 일반적으로 최대 재귀 깊이 제한이 존재
- 함수 호출에 따른 push/pop, context switching 등의 오버헤드가 발생

### 꼬리 재귀 최적화 (Tail Call Optimization)

재귀가 함수의 마지막 동작일 때(꼬리 위치), 스택을 새로 쌓지 않고 현재 스택을 재활용하는 최적화 기법이다.

- Python: 미지원  
- Java: `Function` 타입으로 가능  
- Kotlin: `tailrec` 키워드  
- JavaScript: ES6부터 일부 지원

이 최적화는 재귀를 이터레이션 수준의 효율로 실행할 수 있게 해준다.

---

## 직접 상태 기계를 구현하는 반복

재귀와 이터레이션은 이론적으로 동등하다. 한 방식으로 표현할 수 있는 구조는 다른 방식으로도 표현 가능하다. 이를 활용하면 다음과 같은 전략도 가능하다:

- 언어에서 재귀를 지원하지 않아도 state machine 구조로 반복을 구현할 수 있다.
- 콜 스택이 너무 깊어지는 재귀 호출도 반복 기반의 상태 전이 구조로 바꿔 해결할 수 있다.

예를 들어:

- 단일 상태 변수 기반 반복: `while` 루프
- 복합 상태 기반 반복: stack을 활용한 순회 등

---

## 마무리: 반복, 재귀, 그리고 구조의 이해

프로그래밍 언어에서 반복(repeatation)의 구현 방식인 이터레이션과 재귀는 결국 동일한 상태 전이 모델 위에서 작동한다. 이 둘을 구분 짓는 것은 언어의 문법, 성능 모델, 그리고 메모리 제약 조건일 뿐이다.

반복의 대상이 되는 collection의 구조(array vs linked list)를 이해하고, 각각의 반복 방식이 어떤 상황에서 적절한지를 아는 것은 프로그래밍 언어의 특성을 깊이 있게 이해하는 데 매우 유익하다.

이 글이 반복과 재귀를 바라보는 새로운 관점을 제공하고, 언어 내부의 동작 원리를 이해하는 데 도움이 되었기를 바란다.
