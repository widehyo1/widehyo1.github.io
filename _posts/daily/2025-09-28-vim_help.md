---
layout: post
title: vim-help 저장소
subtitle: :h 
tags: [vim,vimscript]
comments: true
author: widehyo
---

`func-closure`
```help
						*:func-closure* *E932*
			When the [closure] argument is added, the function
			can access variables and arguments from the outer
			scope.  This is usually called a closure.  In this
			example Bar() uses "x" from the scope of Foo().  It
			remains referenced even after Foo() returns: >
				:function! Foo()
				:  let x = 0
				:  function! Bar() closure
				:    let x += 1
				:    return x
				:  endfunction
				:  return funcref('Bar')
				:endfunction

				:let F = Foo()
				:echo F()
<				1 >
				:echo F()
<				2 >
				:echo F()
<				3
```

`playground.vim`

```vim
function! OpenExcommandPopup(excommand, lseek = v:false)
  echo a:excommand
  echo a:lseek
  if a:lseek
    echo "true"
  else
    echo "false"
  endif
endfunction

call OpenExcommandPopup('msg')
"call OpenExcommandPopup('msg', v:true)
```

```vim
function! OpenExcommandPopup(excommand, lseek = v:false)
  let pop_width = float2nr(&columns * 0.8)
  let pop_height = float2nr(&lines * 0.8)
  let lines = split(execute(a:excommand, 'silent'), '\n')
  let popup_config = #{
        \ scrollbar: 1,
        \ maxheight: pop_height,
        \ minheight: pop_height,
        \ maxwidth: pop_width,
        \ minwidth: pop_width,
        \ filter: 'PopupFilter'
        \ }

  let winid = popup_menu(lines, popup_config)

  if a:lseek
    call win_execute(winid, 'normal! G')
    call win_execute(winid, 'normal! \<c-b>')
  endif
endfunction

" call OpenExcommandPopup('message', v:true)
call OpenExcommandPopup('map')
```

```vim
nnoremap <leader>msg :call OpenExcommandPopup('messages', v:true)<CR>
nnoremap <leader>map :call OpenExcommandPopup('map')<CR>
```

`playground.lua`

```lua
local M = {}

function M.floating_window(lines, field, win_opt, buf_opt)
  lines = lines or {}
  local contents = {}

  win_opt = win_opt or {}
  buf_opt = buf_opt or {}

  for _, line in ipairs(lines) do
    table.insert(contents, line)
  end

  local buf = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_lines(buf, 0, -1, false, contents)

  local width = vim.fn.float2nr(vim.o.columns * 0.8)
  local height = vim.fn.float2nr(vim.o.lines * 0.8)

  local win = vim.api.nvim_open_win(buf, true, vim.tbl_deep_extend("force", {
    relative = 'editor',
    width = width,
    height = height,
    row = math.floor((vim.o.lines - height) / 2),
    col = math.floor((vim.o.columns - width) / 2),
    style = 'minimal',
    border = 'rounded',
  }, win_opt))

  -- default window, buffer option
  vim.api.nvim_set_option_value('modifiable', false, {buf=buf})
  vim.api.nvim_set_option_value('cursorline', true, {win=win})

  for key, value in pairs(buf_opt) do
    vim.api.nvim_set_option_value(key, value, {buf=buf})
  end

  return win, buf
end

function M.command_window(cmd, lseek)
  if cmd == nil or cmd == '' then return end
  lseek = lseek or false
  local cmd_result = vim.fn.execute(cmd)
  local lines = vim.split(cmd_result, "\n", { trimempty = true })
  local win, buf = M.floating_window(lines)
  if lseek then
    vim.cmd.normal('G')
  end
end

function M.system_window(cmd, lseek)
  if cmd == nil or cmd == '' then return end
  lseek = lseek or false
  local cmd_result = vim.fn.system(cmd)
  local lines = vim.split(cmd_result, "\n", { trimempty = true })
  local win, buf = M.floating_window(lines)
end

-- M.command_window('map', true)
M.command_window('messages', true)
-- M.system_window('awk -f ~/script.awk ~/temp.txt')
```
