---
layout: post
title: 자료구조에 관한 생각
subtitle: 게임과의 연관성을 중심으로
tags: [data_structure]
comments: true
author: widehyo
---

## 게임개발에 연관성

게임은 기본적으로 multi thread, multi process를 다루어야 한다.
그리고 CS(computer science)의 거의 모든 영역을 다룬다.

비동기와 병렬 프로그래밍을 바로 다루는 것은 당연히 무리가 있고, [이 영상](https://www.youtube.com/watch?v=yl8_ZRDA5pw)에서 말하는 것 처럼 각각의 task를 알기 쉽게 작성하는 연습을 하는 것에 집중하고 있다.

나는 아직 mutex와 lock에 대한 깊은 이해가 없으므로, 병렬 및 비동기 프로그래밍을 한다면(지금 할 생각이거나 할 수 있다는 것이 아니다) 각 프로세스 / 쓰레드가 공유자원을 가지지 않는 상황을 만들려고 노력할 것이다. 그리고 이러한 맥락에서 유리한 구조는 여러 job이 자신의 역할만 수행하면 되는 구조이고, 각각의 job이 독립적으로 동작할 수 있는 구조이다. 이렇게 되면 하나의 job은 주어진 input에 대한 output만 생성하면 되고, 독립적이므로 이는 다른 job의 영향을 받지 않는다. 이 구조가 내가 함수형 프로그래밍에 주목하게 된 계기이며, 함수형 프로그래밍의 용어 중 가장 비슷한 용어는 순수 함수이다.

### dag

문명과 같은 게임의 테크 트리나 시나리오형 게임의 happy / bad ending을 나누는 선택지는 본질적으로 DAG(directional acyclic graph)이며, DAG에 대한 이해는 prerequisite으로 tree와 linked list에 대한 이해를 필요로 한다. 현재는 DAG를 공부하기 위한 정도의 수준으로는 tree에 대한 이해도를 높였고, 그래서 현재 관심을 가지는 자료구조는 DAG이다. DAG를 사용하겠다는 것은 본질적으로 prerequisite이 있는 task들을 다루겠다는 것이고 하나의 task를 수행/처리 하는데에는 시간 및 비용이 소요되고 각 task를 동시에 처리할 수 있는지 한번에 하나의 task만 처리할 수 있는지에 따라서 inorder가 0인 task들(현 시점에서 당장 실행할 수 있는 task)를 병렬로 수행할 수 도 있다.

내가 DAG를 다루면서 이르고자 하는 수준은 두 가지인데, 첫 번째는 한 번에 하나만 처리할 수 있는 상황에서 문명과 같은 topological sort를 직접 구현하는 것이고, 두 번째는 한 번에 여러 task를 병렬로 처리할 수 있는 상황에서 비동기를 이용하여 airflow와 같은 task 수행 작업을 구현하는 것이다.

문명과 같은 게임에서 장창병 타이밍 러쉬를 위하여 공공행정 기술을 연마해야 한다면 게임 플레이 상으로는 단순히 공공행정 기술을 클릭하여 기술 연구 대기열에 등록하면 되지만, 이때 이루어지는 작업은 공공행정이라는 기술의 prerequisite을 모두 만족시키도록 사전 기술을 순차적으로 개발하도록 하며, topological sorting을 지키면서 최적의 순서(소요되는 턴 수, 기회비용 최소화 등(모든 시민을 연구 중심으로 수동배치하면 소요되는 턴수는 최소화되지만 식량과 망치의 감소를 비용으로 한다))로 기술을 연구하는 것과 같다.

airflow는 비동기 수행을 통해 실행 시킬 수 있는 모든 task를 한번에 실행시키며, 실행이 실패한 경우 원인을 파악할 수 있는 방법과 실행 상황을 모니터링 할 수 있는 방법을 제공한다. 각 말단 node에 대하여 root로부터 자신에 이르는 path는 같은 depth를 가지는 task를 하나의 task로 본다면 array로 볼 수 있는데, 상위 task가 실패하면 하위 task는 실행하지 않고 실패하는 성질을 가졌다. 그리고 이 상황에 대한 적합한 모델은 함수형 언어에서의 Maybe(실패한 경우 실패한 상태만 알고 싶을 때) 또는 Either(실패한 경우 실패한 원인까지 추가적으로 알고 싶을 때) 타입이다.

### tree

tree의 가장 큰 특징이라고 하면 subtree is tree. 즉, tree의 부분인 subtree가 하나의 tree 구조를 형성한다는 것이고 이는 곧 tree에서의 가장 자연스러운 동작방식이 재귀라는 것을 의미한다. tree를 이용하는 순간부터는 선형 자료구조가 아닌 2차원 자료구조를 다루게 되며, 이것이 binary search와 같은 알고리즘이 O(n)이 아니라 O(log n)으로 동작할 수 있게 되는 근본적인 이유이기도 하다.

재귀의 기본은 재귀 종료 조건(base condition)과 비즈니스 로직의 구분이다. tree에 대한 문제는 해당 tree에 대한 어떠한 property를 구하는 문제이며 대부분의 경우 재귀 종료조건이 발생할 때 까지 subtree로 쪼개어 subtree에서의 property를 계산하고 이러한 값들을 그러모아 전체 tree에 대한 property를 구하는 형태로 풀이된다. 이 과정에서의 직관은 전체에 대해 한 번에 접근하는 것은 어려우니 부분으로 쪼개어 점차 합쳐나가는 형태로 푸는 전체 -> 부분 방향이 하나가 있고, subtree의 입장에서 자신이 처리하기 어려운 정도의 task가 몰리는 경우 자신을 복제하고 자신과 복제본의 parent가 되는 node를 생성하여 tree를 구성하는 부분 -> 전체 방향이 있다. 후자의 경우는 실제로 대규모 시스템을 설계하는 측면에서 같은 직관을 사용할 수 있다.

### linear structure(array, linked list, generator)

linked list는 함수형 언어와 그렇지 않은 언어에서 collection을 바라보는 기본 시각이 어떻게 다른지를 가장 잘 나타내는 구조이며, 프로그래머 입장에서는 프로그램의 한 step(더 잘게 쪼갠다면 instruction)단위에서 사용하고 있는 메모리의 크기와 관련이 있다. length가 n인 array(list)와 linked list의 차이는 프로그램 런타임에 array는 n개의 원소가 모두 메모리에 올라와 있는 반면, linked list는 data와 next를 가지고 있는 head node만 메모리를 요구한다는 것이다. 후자의 특징으로 인하여 last node에 가까운 node가 필요할 수록 O(n)에 가까운 비용이 소요된다. 그렇다고 array가 linked list보다 항상 좋냐 하면 그건 아니다. linked list는 재귀를 나타내는데 매우 적합하며 이는 사실 linked list를 skewed tree로 해석할 수 있기 때문이다. 또, linked list를 구성하는 각 node를 미리 모두 만들지 않고 필요할 때마다 만든다면 이 구조는 runtime에서 lazy하게 동작하게 되고 array에서는 메모리 상한으로 인해 불가능한 무한을 표현할 수 있게 된다. 사실 이 경우는 list vs. generator에 대한 이야기와 같은데, n이 매우 큰 경우 위력을 발휘한다.

### 자료구조

나는 자료구조에 대한 질문은 본질적으로 pointer를 다룰 줄 아냐고 묻는 것이라고 생각한다. 그리고 이 방식이 실제 컴퓨터가 프로그램을 실행하는 방식이기 때문에 다른 말로는 너는 컴퓨터가 알아듣는 말로(컴퓨터의 언어로) 프로그래밍을 작성할 수 있냐고 물어보는 것이고 보통의 경우는 별로 신경 쓸 필요가 없거나 한 번 쓰고 말거라면 오히려 over engineering이 될 수 있지만, 대용량의 데이터를 다루거나 성능이 중요해지면 결국 자료구조에 도달하게 될 것이라고 생각한다.

### graph

추후에는 경로와 장애물이 있는 상황에서 길찾기 알고리즘인 A* 알고리즘을 공부하여 롤토체스와 같은 hexagonal tile이 주어진 field에서 아군 및 상대의 복수개의 근접 기물이 서로에게 접근하는 알고리즘을 구현하는 것을 목표로 하고 있다.(갈 길이 멀다)


